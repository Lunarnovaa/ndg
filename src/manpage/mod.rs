use std::fs;
use std::io::Write;
use std::path::Path;

use anyhow::{Context, Result};
use log::{debug, info};
use pulldown_cmark::{Event, HeadingLevel, Options, Parser, Tag, TagEnd};

use crate::formatter::manpage::process_markdown_for_manpage;
use crate::formatter::manpage::{escape_leading_dot, escape_manpage, postprocess_manpage};
use crate::formatter::markdown::{collect_markdown_files, extract_headers};

#[cfg(test)]
mod tests;

/// Generate man pages from markdown files in a directory
pub fn generate_manpages_from_directory(
    input_dir: &Path,
    output_dir: &Path,
    section: u8,
    manual: &str,
    _jobs: Option<usize>,
) -> Result<()> {
    fs::create_dir_all(output_dir)?;

    info!("Collecting markdown files from {}", input_dir.display());
    let files = collect_markdown_files(input_dir)?;
    info!(
        "Found {} markdown files to convert to manpages",
        files.len()
    );

    for file_path in &files {
        process_markdown_to_manpage(file_path, input_dir, output_dir, section, manual)?;
    }

    Ok(())
}

/// Process a single markdown file to a man page
fn process_markdown_to_manpage(
    file_path: &Path,
    input_dir: &Path,
    output_dir: &Path,
    section: u8,
    manual: &str,
) -> Result<()> {
    debug!("Converting to manpage: {}", file_path.display());

    let content = fs::read_to_string(file_path)
        .with_context(|| format!("Failed to read markdown file: {}", file_path.display()))?;

    let (_, title_opt) = extract_headers(&content);
    let filename = file_path.file_stem().unwrap_or_default().to_string_lossy();
    let title = title_opt.unwrap_or_else(|| filename.to_string());

    let rel_path = file_path.strip_prefix(input_dir).with_context(|| {
        format!(
            "Failed to determine relative path for {}",
            file_path.display()
        )
    })?;

    let mut output_path = output_dir.join(rel_path);
    output_path.set_extension(section.to_string());

    if let Some(parent) = output_path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }

    let manpage_content = markdown_to_manpage(&content, &title, section, manual)?;

    fs::write(&output_path, manpage_content)
        .with_context(|| format!("Failed to write manpage file: {}", output_path.display()))?;

    info!("Generated manpage: {}", output_path.display());

    Ok(())
}

/// Convert markdown content to a man page
pub fn markdown_to_manpage(
    markdown: &str,
    title: &str,
    section: u8,
    manual: &str,
) -> Result<String> {
    let mut manpage = Vec::with_capacity(markdown.len() * 2);

    // Preprocess the markdown for man page format using the new parser
    let processed_markdown = process_markdown_for_manpage(markdown);

    let mut options = Options::empty();
    options.insert(Options::ENABLE_TABLES);
    options.insert(Options::ENABLE_FOOTNOTES);
    options.insert(Options::ENABLE_STRIKETHROUGH);
    options.insert(Options::ENABLE_TASKLISTS);

    let parser = Parser::new_ext(&processed_markdown, options);

    // Write the man page header
    let today = chrono::Local::now().format("%Y-%m-%d").to_string();
    writeln!(manpage, ".\\\" Generated by ndg")?;
    writeln!(
        manpage,
        ".TH \"{}\" \"{}\" \"{}\" \"\" \"{}\"",
        escape_manpage(title),
        section,
        today,
        escape_manpage(manual)
    )?;

    // State tracking for the document parsing
    let mut state = ParserState::default();

    // Process each markdown event and convert to man page format
    for event in parser {
        process_markdown_event(event, &mut manpage, &mut state)?;
    }

    // Convert the buffer to a string and apply post-processing fixes
    let result = String::from_utf8(manpage)?;
    Ok(postprocess_manpage(&result))
}

/// State for tracking parser context
#[derive(Default)]
struct ParserState {
    current_list_level: usize,
    in_list_item: bool,
    in_code_block: bool,
    code_block_content: String,
    table_headers: Vec<String>,
    table_rows: Vec<Vec<String>>,
    current_row: Vec<String>,
    current_cell: String,
    in_header: bool,
    in_row: bool,
    in_table: bool,
    current_item_content: String,
}

/// Process a single markdown event and write appropriate man page content
fn process_markdown_event(
    event: Event,
    manpage: &mut Vec<u8>,
    state: &mut ParserState,
) -> Result<()> {
    match event {
        Event::Start(Tag::Heading { level, .. }) => {
            if state.in_list_item {
                if !state.current_item_content.is_empty() {
                    write!(manpage, "{}", state.current_item_content)?;
                    state.current_item_content.clear();
                }
                writeln!(manpage)?;
                state.in_list_item = false;
            }

            let section_macro = match level {
                HeadingLevel::H1 => ".SH",
                _ => ".SS",
            };

            write!(manpage, "{section_macro} \"")?;
        }

        Event::End(TagEnd::Heading(_)) => {
            writeln!(manpage, "\"")?;
        }

        Event::Start(Tag::Paragraph) => {
            if !state.in_list_item {
                writeln!(manpage, ".PP")?;
            }
        }

        Event::End(TagEnd::Paragraph) => {
            if !state.in_list_item {
                writeln!(manpage)?;
            }
        }

        Event::Start(Tag::List(_)) => {
            state.current_list_level += 1;
            if state.current_list_level == 1 {
                writeln!(manpage, ".RS")?;
            }
        }

        Event::End(TagEnd::List(_)) => {
            state.current_list_level -= 1;
            if state.current_list_level == 0 {
                writeln!(manpage, ".RE")?;
            }
            state.in_list_item = false;
            state.current_item_content.clear();
        }

        Event::Start(Tag::Item) => {
            if state.in_list_item && !state.current_item_content.is_empty() {
                write!(manpage, "{}", state.current_item_content)?;
                state.current_item_content.clear();
            }
            state.in_list_item = true;
            writeln!(manpage, ".IP \\(bu 2")?;
        }

        Event::End(TagEnd::Item) => {
            if !state.current_item_content.is_empty() {
                write!(manpage, "{}", state.current_item_content)?;
                state.current_item_content.clear();
            }
            writeln!(manpage)?;
        }

        Event::Start(Tag::CodeBlock(_)) => {
            state.in_code_block = true;
            state.code_block_content.clear();
            writeln!(manpage, ".PP")?;
            writeln!(manpage, ".RS 4")?;
            writeln!(manpage, ".nf")?;
        }

        Event::End(TagEnd::CodeBlock) => {
            state.in_code_block = false;
            for line in state.code_block_content.lines() {
                writeln!(manpage, "{}", escape_leading_dot(line))?;
            }
            writeln!(manpage, ".fi")?;
            writeln!(manpage, ".RE")?;
        }

        Event::Start(Tag::Table(_)) => {
            state.in_table = true;
            state.table_headers.clear();
            state.table_rows.clear();
        }

        Event::End(TagEnd::Table) => {
            state.in_table = false;
            render_table(manpage, &state.table_headers, &state.table_rows)?;
        }

        Event::Start(Tag::TableHead) => {
            state.in_header = true;
        }

        Event::End(TagEnd::TableHead) => {
            state.in_header = false;
        }

        Event::Start(Tag::TableRow) => {
            state.in_row = true;
            state.current_row.clear();
        }

        Event::End(TagEnd::TableRow) => {
            state.in_row = false;
            if !state.in_header {
                state.table_rows.push(state.current_row.clone());
            }
        }

        Event::Start(Tag::TableCell) => {
            state.current_cell.clear();
        }

        Event::End(TagEnd::TableCell) => {
            if state.in_header {
                state.table_headers.push(state.current_cell.clone());
            } else if state.in_row {
                state.current_row.push(state.current_cell.clone());
            }
        }

        Event::Code(text) => {
            if state.in_table {
                if state.in_header || state.in_row {
                    state.current_cell.push_str(&text);
                }
            } else if state.in_code_block {
                state.code_block_content.push_str(&text);
            } else if state.in_list_item {
                if text.contains("\\fB") || text.contains("\\fI") || text.contains("\\fR") {
                    state.current_item_content.push_str(&text);
                } else {
                    state
                        .current_item_content
                        .push_str(&format!("\\fB{}\\fR", escape_manpage(&text)));
                }
            } else if text.contains("\\fB") || text.contains("\\fI") || text.contains("\\fR") {
                write!(manpage, "{text}")?;
            } else {
                write!(manpage, "\\fB{}\\fR", escape_manpage(&text))?;
            }
        }

        Event::Start(Tag::Emphasis) => {
            if state.in_list_item {
                state.current_item_content.push_str("\\fI");
            } else if !state.in_table && !state.in_code_block {
                write!(manpage, "\\fI")?;
            }
        }

        Event::End(TagEnd::Emphasis) => {
            if state.in_list_item {
                state.current_item_content.push_str("\\fR");
            } else if !state.in_table && !state.in_code_block {
                write!(manpage, "\\fR")?;
            }
        }

        Event::Start(Tag::Strong) => {
            if state.in_list_item {
                state.current_item_content.push_str("\\fB");
            } else if !state.in_table && !state.in_code_block {
                write!(manpage, "\\fB")?;
            }
        }

        Event::End(TagEnd::Strong) => {
            if state.in_list_item {
                state.current_item_content.push_str("\\fR");
            } else if !state.in_table && !state.in_code_block {
                write!(manpage, "\\fR")?;
            }
        }

        Event::Text(text) => {
            let text_str = text.as_ref();
            process_text(manpage, state, text_str)?;
        }

        Event::SoftBreak => {
            if state.in_code_block {
                state.code_block_content.push('\n');
            } else if state.in_list_item {
                state.current_item_content.push(' ');
            } else if !state.in_table {
                write!(manpage, " ")?;
            }
        }

        Event::HardBreak => {
            if state.in_code_block {
                state.code_block_content.push('\n');
            } else if state.in_list_item {
                state.current_item_content.push_str("\n.br\n");
            } else if !state.in_table {
                writeln!(manpage, ".br")?;
            }
        }

        Event::FootnoteReference(footnote_id) => {
            let formatted = format!("[{}]", escape_manpage(&footnote_id));
            if state.in_list_item {
                state.current_item_content.push_str(&formatted);
            } else {
                write!(manpage, "{formatted}")?;
            }
        }

        Event::TaskListMarker(checked) => {
            let formatted = format!("[{}] ", if checked { "x" } else { " " });
            if state.in_list_item {
                state.current_item_content.push_str(&formatted);
            } else {
                write!(manpage, "{formatted}")?;
            }
        }

        _ => {}
    }
    Ok(())
}

/// Process text content appropriately based on context
fn process_text(manpage: &mut Vec<u8>, state: &mut ParserState, text_str: &str) -> Result<()> {
    if text_str.starts_with('.') && !state.in_code_block && !state.in_table {
        if text_str.starts_with(".PP")
            || text_str.starts_with(".RS")
            || text_str.starts_with(".RE")
            || text_str.starts_with(".B ")
            || text_str.starts_with(".TP")
            || text_str.starts_with(".br")
            || text_str.starts_with(".nf")
            || text_str.starts_with(".fi")
            || text_str.starts_with(".BR")
        {
            if state.in_list_item {
                state.current_item_content.push_str(text_str);
            } else {
                write!(manpage, "{text_str}")?;
            }
        } else if state.in_header || state.in_row {
            state.current_cell.push_str(&escape_leading_dot(text_str));
        } else if state.in_list_item {
            state
                .current_item_content
                .push_str(&escape_leading_dot(text_str));
        } else {
            write!(manpage, "{}", escape_leading_dot(text_str))?;
        }
    } else if state.in_table {
        if state.in_header || state.in_row {
            state.current_cell.push_str(text_str);
        }
    } else if state.in_code_block {
        state.code_block_content.push_str(text_str);
    } else if state.in_list_item {
        state
            .current_item_content
            .push_str(&escape_manpage(text_str));
    } else {
        write!(manpage, "{}", escape_manpage(text_str))?;
    }
    Ok(())
}

/// Render a table in ASCII art style
fn render_table(manpage: &mut Vec<u8>, headers: &[String], rows: &[Vec<String>]) -> Result<()> {
    writeln!(manpage, ".PP")?;
    writeln!(manpage, ".nf")?;

    let max_cols = std::cmp::max(
        headers.len(),
        rows.iter().map(std::vec::Vec::len).max().unwrap_or(0),
    );

    let mut col_widths = vec![0; max_cols];

    // Calculate column widths
    for (i, header) in headers.iter().enumerate() {
        if i < col_widths.len() {
            col_widths[i] = col_widths[i].max(header.len());
        }
    }

    for row in rows {
        for (i, cell) in row.iter().enumerate() {
            if i < col_widths.len() {
                col_widths[i] = col_widths[i].max(cell.len());
            }
        }
    }

    // Add padding to column widths
    for width in &mut col_widths {
        *width += 2;
    }

    // Draw table top border
    write!(manpage, "┌")?;
    for (i, &width) in col_widths.iter().enumerate() {
        write!(manpage, "{}", "─".repeat(width))?;
        if i < col_widths.len() - 1 {
            write!(manpage, "┬")?;
        }
    }
    writeln!(manpage, "┐")?;

    // Draw table headers if present
    if !headers.is_empty() {
        write!(manpage, "│")?;
        for (i, header) in headers.iter().enumerate() {
            if i < col_widths.len() {
                let padding = col_widths[i] - header.len();
                let left_pad = padding / 2;
                let right_pad = padding - left_pad;

                write!(
                    manpage,
                    "{}{}{}",
                    " ".repeat(left_pad),
                    header,
                    " ".repeat(right_pad)
                )?;

                if i < headers.len() - 1 {
                    write!(manpage, "│")?;
                }
            }
        }
        writeln!(manpage, "│")?;

        write!(manpage, "├")?;
        for (i, &width) in col_widths.iter().enumerate() {
            write!(manpage, "{}", "─".repeat(width))?;
            if i < col_widths.len() - 1 {
                write!(manpage, "┼")?;
            }
        }
        writeln!(manpage, "┤")?;
    }

    // Draw table rows
    for (row_idx, row) in rows.iter().enumerate() {
        write!(manpage, "│")?;

        for (i, cell) in row.iter().enumerate() {
            if i < col_widths.len() {
                let cell_width: usize = col_widths[i];
                let content_width = cell.len();
                let padding = cell_width.saturating_sub(content_width);
                let left_pad = padding / 2;
                let right_pad = padding - left_pad;

                write!(
                    manpage,
                    "{}{}{}",
                    " ".repeat(left_pad),
                    cell,
                    " ".repeat(right_pad)
                )?;

                if i < row.len() - 1 && i < col_widths.len() - 1 {
                    write!(manpage, "│")?;
                }
            }
        }

        // Fill empty cells
        if row.len() < col_widths.len() {
            for i in row.len()..col_widths.len() {
                if i > 0 {
                    write!(manpage, "│")?;
                }
                write!(manpage, "{}", " ".repeat(col_widths[i]))?;
            }
        }

        writeln!(manpage, "│")?;

        // Draw row separator unless it's the last row
        if row_idx < rows.len() - 1 {
            write!(manpage, "├")?;
            for (i, &width) in col_widths.iter().enumerate() {
                write!(manpage, "{}", "─".repeat(width))?;
                if i < col_widths.len() - 1 {
                    write!(manpage, "┼")?;
                }
            }
            writeln!(manpage, "┤")?;
        }
    }

    // Draw table bottom border
    write!(manpage, "└")?;
    for (i, &width) in col_widths.iter().enumerate() {
        write!(manpage, "{}", "─".repeat(width))?;
        if i < col_widths.len() - 1 {
            write!(manpage, "┴")?;
        }
    }
    writeln!(manpage, "┘")?;
    writeln!(manpage, ".fi")?;

    Ok(())
}
