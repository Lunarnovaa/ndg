use std::fs;
use std::io::Write;
use std::path::Path;

use anyhow::{Context, Result};
use lazy_static::lazy_static;
use log::{debug, info};
use pulldown_cmark::{Event, HeadingLevel, Options, Parser, Tag, TagEnd};
use regex::Regex;

use crate::markdown::extract_headers;
use crate::markdown::preprocess::{preprocess_markdown, FormatType};

mod formatter;
#[cfg(test)]
mod tests;

use formatter::escape_leading_dot;
pub use formatter::escape_manpage;

pub fn generate_manpages_from_directory(
    input_dir: &Path,
    output_dir: &Path,
    section: u8,
    manual: &str,
    _jobs: Option<usize>,
) -> Result<()> {
    fs::create_dir_all(output_dir)?;

    info!("Collecting markdown files from {}", input_dir.display());
    let files = crate::markdown::collect_markdown_files(input_dir)?;
    info!(
        "Found {} markdown files to convert to manpages",
        files.len()
    );

    if !files.is_empty() {
        for file_path in &files {
            process_markdown_to_manpage(file_path, input_dir, output_dir, section, manual)?;
        }
    }

    Ok(())
}

fn process_markdown_to_manpage(
    file_path: &Path,
    input_dir: &Path,
    output_dir: &Path,
    section: u8,
    manual: &str,
) -> Result<()> {
    debug!("Converting to manpage: {}", file_path.display());

    let content = fs::read_to_string(file_path)
        .with_context(|| format!("Failed to read markdown file: {}", file_path.display()))?;

    let (_, title_opt) = extract_headers(&content);
    let filename = file_path.file_stem().unwrap_or_default().to_string_lossy();

    let title = title_opt.unwrap_or_else(|| filename.to_string());

    let rel_path = file_path.strip_prefix(input_dir).with_context(|| {
        format!(
            "Failed to determine relative path for {}",
            file_path.display()
        )
    })?;

    let mut output_path = output_dir.join(rel_path);
    output_path.set_extension(section.to_string());

    if let Some(parent) = output_path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }

    let manpage_content = markdown_to_manpage(&content, &title, section, manual)?;

    fs::write(&output_path, manpage_content)
        .with_context(|| format!("Failed to write manpage file: {}", output_path.display()))?;

    info!("Generated manpage: {}", output_path.display());

    Ok(())
}

pub fn markdown_to_manpage(
    markdown: &str,
    title: &str,
    section: u8,
    manual: &str,
) -> Result<String> {
    let mut manpage = Vec::with_capacity(markdown.len() * 2);

    let processed_markdown = preprocess_markdown(markdown, FormatType::Manpage);

    let mut options = Options::empty();
    options.insert(Options::ENABLE_TABLES);
    options.insert(Options::ENABLE_FOOTNOTES);
    options.insert(Options::ENABLE_STRIKETHROUGH);
    options.insert(Options::ENABLE_TASKLISTS);

    let parser = Parser::new_ext(&processed_markdown, options);

    let today = chrono::Local::now().format("%Y-%m-%d").to_string();
    writeln!(manpage, ".\\\" Generated by ndg")?;
    writeln!(
        manpage,
        ".TH \"{}\" \"{}\" \"{}\" \"\" \"{}\"",
        escape_manpage(title),
        section,
        today,
        escape_manpage(manual)
    )?;

    let mut current_list_level = 0;
    let mut in_list_item = false;
    let mut in_code_block = false;
    let mut code_block_content = String::new();
    let mut table_headers: Vec<String> = Vec::new();
    let mut table_rows: Vec<Vec<String>> = Vec::new();
    let mut current_row: Vec<String> = Vec::new();
    let mut current_cell = String::new();
    let mut in_header = false;
    let mut in_row = false;
    let mut in_table = false;
    let mut current_item_content = String::new();

    for event in parser {
        match event {
            Event::Start(Tag::Heading { level, .. }) => {
                if in_list_item {
                    if !current_item_content.is_empty() {
                        write!(manpage, "{current_item_content}")?;
                        current_item_content.clear();
                    }
                    writeln!(manpage)?;
                    in_list_item = false;
                }

                let section_macro = match level {
                    HeadingLevel::H1 => ".SH",
                    _ => ".SS",
                };

                write!(manpage, "{section_macro} \"")?;
            }

            Event::End(TagEnd::Heading(_)) => {
                writeln!(manpage, "\"")?;
            }

            Event::Start(Tag::Paragraph) => {
                if in_list_item {
                    // For paragraphs inside list items, we'll append to current content
                } else {
                    writeln!(manpage, ".PP")?;
                }
            }

            Event::End(TagEnd::Paragraph) => {
                if !in_list_item {
                    writeln!(manpage)?;
                }
            }

            Event::Start(Tag::List(_)) => {
                current_list_level += 1;
                if current_list_level == 1 {
                    writeln!(manpage, ".RS")?;
                }
            }

            Event::End(TagEnd::List(_)) => {
                current_list_level -= 1;
                if current_list_level == 0 {
                    writeln!(manpage, ".RE")?;
                }
                in_list_item = false;
                current_item_content.clear();
            }

            Event::Start(Tag::Item) => {
                // Write any pending content from previous list item
                if in_list_item && !current_item_content.is_empty() {
                    write!(manpage, "{current_item_content}")?;
                    current_item_content.clear();
                }
                in_list_item = true;
                writeln!(manpage, ".IP \\(bu 2")?;
            }

            Event::End(TagEnd::Item) => {
                // Write the list item content at the end of the item
                if !current_item_content.is_empty() {
                    write!(manpage, "{current_item_content}")?;
                    current_item_content.clear();
                }
                // Ensure a newline after each list item
                writeln!(manpage)?;
            }

            Event::Start(Tag::CodeBlock(_)) => {
                in_code_block = true;
                code_block_content.clear();
                writeln!(manpage, ".PP")?;
                writeln!(manpage, ".RS 4")?;
                writeln!(manpage, ".nf")?;
            }

            Event::End(TagEnd::CodeBlock) => {
                in_code_block = false;
                for line in code_block_content.lines() {
                    writeln!(manpage, "{}", escape_leading_dot(line))?;
                }
                writeln!(manpage, ".fi")?;
                writeln!(manpage, ".RE")?;
            }

            Event::Start(Tag::Table(_)) => {
                in_table = true;
                table_headers.clear();
                table_rows.clear();
            }

            Event::End(TagEnd::Table) => {
                in_table = false;
                writeln!(manpage, ".PP")?;
                writeln!(manpage, ".nf")?;

                let max_cols = std::cmp::max(
                    table_headers.len(),
                    table_rows
                        .iter()
                        .map(|row: &Vec<String>| row.len())
                        .max()
                        .unwrap_or(0),
                );

                let mut col_widths = vec![0; max_cols];

                for (i, header) in table_headers.iter().enumerate() {
                    if i < col_widths.len() {
                        col_widths[i] = col_widths[i].max(header.len());
                    }
                }

                for row in &table_rows {
                    for (i, cell) in row.iter().enumerate() {
                        if i < col_widths.len() {
                            col_widths[i] = col_widths[i].max(cell.len());
                        }
                    }
                }

                for width in &mut col_widths {
                    *width += 2;
                }

                write!(manpage, "┌")?;
                for (i, &width) in col_widths.iter().enumerate() {
                    write!(manpage, "{}", "─".repeat(width))?;
                    if i < col_widths.len() - 1 {
                        write!(manpage, "┬")?;
                    }
                }
                writeln!(manpage, "┐")?;

                if !table_headers.is_empty() {
                    write!(manpage, "│")?;
                    for (i, header) in table_headers.iter().enumerate() {
                        if i < col_widths.len() {
                            let padding = col_widths[i] - header.len();
                            let left_pad = padding / 2;
                            let right_pad = padding - left_pad;

                            write!(
                                manpage,
                                "{}{}{}",
                                " ".repeat(left_pad),
                                header,
                                " ".repeat(right_pad)
                            )?;

                            if i < table_headers.len() - 1 {
                                write!(manpage, "│")?;
                            }
                        }
                    }
                    writeln!(manpage, "│")?;

                    write!(manpage, "├")?;
                    for (i, &width) in col_widths.iter().enumerate() {
                        write!(manpage, "{}", "─".repeat(width))?;
                        if i < col_widths.len() - 1 {
                            write!(manpage, "┼")?;
                        }
                    }
                    writeln!(manpage, "┤")?;
                }

                for (row_idx, row) in table_rows.iter().enumerate() {
                    write!(manpage, "│")?;

                    for (i, cell) in row.iter().enumerate() {
                        if i < col_widths.len() {
                            let cell_width: usize = col_widths[i];
                            let content_width = cell.len();
                            let padding = cell_width.saturating_sub(content_width);
                            let left_pad = padding / 2;
                            let right_pad = padding - left_pad;

                            write!(
                                manpage,
                                "{}{}{}",
                                " ".repeat(left_pad),
                                cell,
                                " ".repeat(right_pad)
                            )?;

                            if i < row.len() - 1 && i < col_widths.len() - 1 {
                                write!(manpage, "│")?;
                            }
                        }
                    }

                    if row.len() < col_widths.len() {
                        for i in row.len()..col_widths.len() {
                            if i > 0 {
                                write!(manpage, "│")?;
                            }
                            write!(manpage, "{}", " ".repeat(col_widths[i]))?;
                        }
                    }

                    writeln!(manpage, "│")?;

                    if row_idx < table_rows.len() - 1 {
                        write!(manpage, "├")?;
                        for (i, &width) in col_widths.iter().enumerate() {
                            write!(manpage, "{}", "─".repeat(width))?;
                            if i < col_widths.len() - 1 {
                                write!(manpage, "┼")?;
                            }
                        }
                        writeln!(manpage, "┤")?;
                    }
                }

                write!(manpage, "└")?;
                for (i, &width) in col_widths.iter().enumerate() {
                    write!(manpage, "{}", "─".repeat(width))?;
                    if i < col_widths.len() - 1 {
                        write!(manpage, "┴")?;
                    }
                }
                writeln!(manpage, "┘")?;
                writeln!(manpage, ".fi")?;
            }

            Event::Start(Tag::TableHead) => {
                in_header = true;
            }

            Event::End(TagEnd::TableHead) => {
                in_header = false;
            }

            Event::Start(Tag::TableRow) => {
                in_row = true;
                current_row.clear();
            }

            Event::End(TagEnd::TableRow) => {
                in_row = false;
                if !in_header {
                    table_rows.push(current_row.clone());
                }
            }

            Event::Start(Tag::TableCell) => {
                current_cell.clear();
            }

            Event::End(TagEnd::TableCell) => {
                if in_header {
                    table_headers.push(current_cell.clone());
                } else if in_row {
                    current_row.push(current_cell.clone());
                }
            }

            Event::Code(text) => {
                if in_table {
                    if in_header || in_row {
                        current_cell.push_str(&text);
                    }
                } else if in_code_block {
                    code_block_content.push_str(&text);
                } else if in_list_item {
                    // For list items, collect the content first
                    if text.contains("\\fB") || text.contains("\\fI") || text.contains("\\fR") {
                        current_item_content.push_str(&text);
                    } else {
                        current_item_content
                            .push_str(&format!("\\fB{}\\fR", escape_manpage(&text)));
                    }
                } else if text.contains("\\fB") || text.contains("\\fI") || text.contains("\\fR") {
                    write!(manpage, "{text}")?;
                } else {
                    write!(manpage, "\\fB{}\\fR", escape_manpage(&text))?;
                }
            }

            Event::Start(Tag::Emphasis) => {
                if in_list_item {
                    current_item_content.push_str("\\fI");
                } else if !in_table && !in_code_block {
                    write!(manpage, "\\fI")?;
                }
            }

            Event::End(TagEnd::Emphasis) => {
                if in_list_item {
                    current_item_content.push_str("\\fR");
                } else if !in_table && !in_code_block {
                    write!(manpage, "\\fR")?;
                }
            }

            Event::Start(Tag::Strong) => {
                if in_list_item {
                    current_item_content.push_str("\\fB");
                } else if !in_table && !in_code_block {
                    write!(manpage, "\\fB")?;
                }
            }

            Event::End(TagEnd::Strong) => {
                if in_list_item {
                    current_item_content.push_str("\\fR");
                } else if !in_table && !in_code_block {
                    write!(manpage, "\\fR")?;
                }
            }

            Event::Text(text) => {
                let text_str = text.as_ref();

                if text_str.starts_with('.') && !in_code_block && !in_table {
                    if text_str.starts_with(".PP")
                        || text_str.starts_with(".RS")
                        || text_str.starts_with(".RE")
                        || text_str.starts_with(".B ")
                        || text_str.starts_with(".TP")
                        || text_str.starts_with(".br")
                        || text_str.starts_with(".nf")
                        || text_str.starts_with(".fi")
                        || text_str.starts_with(".BR")
                    {
                        if in_list_item {
                            current_item_content.push_str(text_str);
                        } else {
                            write!(manpage, "{text_str}")?;
                        }
                    } else if in_header || in_row {
                        current_cell.push_str(&escape_leading_dot(text_str));
                    } else if in_list_item {
                        current_item_content.push_str(&escape_leading_dot(text_str));
                    } else {
                        write!(manpage, "{}", escape_leading_dot(text_str))?;
                    }
                } else if in_table {
                    if in_header || in_row {
                        current_cell.push_str(text_str);
                    }
                } else if in_code_block {
                    code_block_content.push_str(text_str);
                } else if in_list_item {
                    current_item_content.push_str(&escape_manpage(text_str));
                } else {
                    write!(manpage, "{}", escape_manpage(text_str))?;
                }
            }

            Event::SoftBreak => {
                if in_code_block {
                    code_block_content.push('\n');
                } else if in_list_item {
                    current_item_content.push(' ');
                } else if !in_table {
                    write!(manpage, " ")?;
                }
            }

            Event::HardBreak => {
                if in_code_block {
                    code_block_content.push('\n');
                } else if in_list_item {
                    current_item_content.push_str("\n.br\n");
                } else if !in_table {
                    writeln!(manpage, ".br")?;
                }
            }

            Event::FootnoteReference(footnote_id) => {
                let formatted = format!("[{}]", escape_manpage(&footnote_id));
                if in_list_item {
                    current_item_content.push_str(&formatted);
                } else {
                    write!(manpage, "{formatted}")?;
                }
            }

            Event::TaskListMarker(checked) => {
                let formatted = format!("[{}] ", if checked { "x" } else { " " });
                if in_list_item {
                    current_item_content.push_str(&formatted);
                } else {
                    write!(manpage, "{formatted}")?;
                }
            }

            _ => {}
        }
    }

    let mut result = String::from_utf8(manpage)?;

    lazy_static! {
        static ref LIST_ITEM_CLEANUP: Regex = Regex::new("(\\\\f[BI][^\\\\]+\\\\fR)\\.IP").unwrap();
        static ref STRAY_IP_BULLET: Regex = Regex::new("\\.IP • 2").unwrap();
        static ref TRAILING_RE: Regex = Regex::new("\\\\fR\\.RE").unwrap();
        static ref DOUBLE_NEWLINE_RE: Regex = Regex::new("\n\n").unwrap();
        static ref DUPLICATE_PP: Regex = Regex::new("\\.PP\n\\.PP").unwrap();
        static ref EXAMPLE_HASH_CLEANUP: Regex = Regex::new("Example:\\s*# (.+)").unwrap();
        static ref INLINE_PP_RE: Regex = Regex::new(r"([^\n])\s*\.PP\s+").unwrap();
        static ref ADMONITION_PARAGRAPH_FIX: Regex =
            Regex::new("(.PP\n[A-Z][a-z]+: .+)(\\.PP)").unwrap();
    }

    // Fix duplicate paragraph markers
    result = DUPLICATE_PP.replace_all(&result, ".PP").to_string();

    // Clean up list item markup
    result = LIST_ITEM_CLEANUP
        .replace_all(&result, "$1\n.IP")
        .to_string();

    // Fix example admonitions with # in title
    result = EXAMPLE_HASH_CLEANUP
        .replace_all(&result, "Example: $1")
        .to_string();

    // Fix paragraph breaks within admonitions
    result = ADMONITION_PARAGRAPH_FIX
        .replace_all(&result, "$1\n.br\n")
        .to_string();

    result = TRAILING_RE.replace_all(&result, "\\fR\n.RE").to_string();
    result = STRAY_IP_BULLET.replace_all(&result, "").to_string();

    // Normalize multiple newlines to single newlines where appropriate
    result = DOUBLE_NEWLINE_RE.replace_all(&result, "\n").to_string();
    result = INLINE_PP_RE.replace_all(&result, "$1\n.PP\n").to_string();

    // Fix escaping issues: we want \f not \\f for troff formatting codes
    result = result.replace("\\\\fB", "\\fB");
    result = result.replace("\\\\fI", "\\fI");
    result = result.replace("\\\\fR", "\\fR");

    Ok(result)
}
